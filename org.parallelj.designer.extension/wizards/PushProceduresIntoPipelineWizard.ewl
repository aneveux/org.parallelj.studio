wizard PushProcedures {

	// if one or more simple procedures (i.e. not pipeline procedures) selected then only execute the wizard.
	guard {
			if(self.isKindOf(Collection)){
				for(selectedObject in self){
					if(not selectedObject.isTypeOf(Procedure) or selectedObject.eContainer.isKindOf(Pipeline)){
						return false;
					}
				}
				return true;
			}
			// for single procedure
			else if(self.isTypeOf(Procedure) and not self.eContainer.isKindOf(Pipeline)){
				return true;
			}
			else{
				return false;
			}
		}

	// sub-menu title
	title : 'Push into Pipeline'

	do {
		// asking user to enter name for new Pipeline
		var newName : String;
		var message : String := 'Please provide a name for new Pipeline';
		newName := UserInput.prompt(message);
		
		// don't create Pipeline if name enter is empty
		if(newName = ''){return;}
		
		var referenceProcedure = null;
		
		// if multiple procedures selected
		if(self.isKindOf(Collection)){
			referenceProcedure = self[0];
		}
		// for single procedure
		else if(self.isTypeOf(Procedure)){
			referenceProcedure = self;
		}
		
		var parent = referenceProcedure.eContainer;
		
		// creating new Pipeline object and giving name which is enter by user
		var pipelineClass = referenceProcedure.eClass().ePackage.getEClassifier('Pipeline');
		var pipelineObject = referenceProcedure.eClass().ePackage.eFactoryInstance.create(pipelineClass);
		pipelineObject.name := newName;
		
		// for mutiple selection
		if(self.isKindOf(Collection)){
			var count = 0;
			// linking pipeline as per procedure incoming and outgoing links 
			while (count < self.size()) {
				
				// add all incoming links to pipeline
				pipelineObject.inputLinks.addAll(self[count].inputLinks);
				// add all outgoing links to pipeline
				pipelineObject.outputLinks.addAll(self[count].outputLinks);
				
				// clearing all self reference
				self[count].outputLinks.clear();
				self[count].inputLinks.clear();
			
				// push selected procedures in pipeline	
				pipelineObject.procedures.add(self[count]);
	
				// next selected procedure
				count = count + 1;
			}
		}
		// when only single procedure is selected
		else if(self.isTypeOf(Procedure)){
			// linking
			pipelineObject.inputLinks.addAll(self.inputLinks);
			pipelineObject.outputLinks.addAll(self.outputLinks);
			self.outputLinks.clear();
			self.inputLinks.clear();
			
			// push selected procedure in pipeline
			pipelineObject.procedures.add(self);
		}
		
		
		// removing invalid inputlinks
		var count = 0;
		while(count < pipelineObject.inputLinks.size()){
			// removing inputlinks coming from and going to selected procedures
			if(pipelineObject.inputLinks[count].eContainer == pipelineObject){
				pipelineObject.outputLinks.remove(pipelineObject.inputLinks[count]);
				pipelineObject.inputLinks.remove(pipelineObject.inputLinks[count]);				
			} else {
				var innerCount = 0;
				while(innerCount < pipelineObject.inputLinks.size()){
					// removing duplicate incoming links from same object 
					if(count <> innerCount and pipelineObject.inputLinks[count].eContainer == pipelineObject.inputLinks[innerCount].eContainer){
						pipelineObject.inputLinks[innerCount].eContainer.outputLinks.remove(pipelineObject.inputLinks[innerCount]);
						pipelineObject.inputLinks.remove(pipelineObject.inputLinks[innerCount]);
					} else {
						innerCount = innerCount + 1;
					}
				}
				count = count + 1;
			}
		}
		
		// removing duplicate outgoing links to same object
		count = 0;
		while(count < pipelineObject.outputLinks.size()){
			var innerCount = 0;
			while(innerCount < pipelineObject.outputLinks.size()){
				if(count <> innerCount and pipelineObject.outputLinks[count].destination == pipelineObject.outputLinks[innerCount].destination){
					pipelineObject.outputLinks[innerCount].destination.inputLinks.remove(pipelineObject.outputLinks[innerCount]);
					pipelineObject.outputLinks.remove(pipelineObject.outputLinks[innerCount]);
				} else {
					innerCount = innerCount + 1;
				}
			}
			count = count + 1;
		}
		
		// adding to new object to container
		parent.elements.add(pipelineObject);
	}
}